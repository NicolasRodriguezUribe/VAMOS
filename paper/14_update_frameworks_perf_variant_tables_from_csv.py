"""
Update per-algorithm runtime tables (frameworks_perf_*.tex) for the manuscript.

These tables are included in `paper/manuscript/main.tex` via `\\input{...}` and are
generated from the committed benchmark CSVs in `experiments/`.

Usage:
  python paper/14_update_frameworks_perf_variant_tables_from_csv.py
  python paper/14_update_frameworks_perf_variant_tables_from_csv.py --algo nsgaii_ss
"""

from __future__ import annotations

import argparse
from pathlib import Path

import pandas as pd


ROOT_DIR = Path(__file__).parent.parent
DATA_DIR = ROOT_DIR / "experiments"
MANUSCRIPT_DIR = Path(__file__).parent / "manuscript"


TABLE_SPECS: dict[str, dict[str, str]] = {
    "nsgaii_ss": {
        "csv": str(DATA_DIR / "benchmark_paper_nsgaii_ss.csv"),
        "out": str(MANUSCRIPT_DIR / "frameworks_perf_nsgaii_ss.tex"),
        "label": "tab:frameworks_perf_nsgaii_ss",
        "caption": "NSGA-II (steady-state). Median runtime (seconds) by problem family across all frameworks",
    },
    "nsgaii_archive": {
        "csv": str(DATA_DIR / "benchmark_paper_nsgaii_archive.csv"),
        "out": str(MANUSCRIPT_DIR / "frameworks_perf_nsgaii_archive.tex"),
        "label": "tab:frameworks_perf_nsgaii_archive",
        "caption": "NSGA-II (ext. archive). Median runtime (seconds) by problem family across frameworks",
    },
    "smsemoa": {
        "csv": str(DATA_DIR / "benchmark_paper_smsemoa.csv"),
        "out": str(MANUSCRIPT_DIR / "frameworks_perf_smsemoa.tex"),
        "label": "tab:frameworks_perf_smsemoa",
        "caption": "SMS-EMOA. Median runtime (seconds) by problem family across all frameworks",
    },
    "moead": {
        "csv": str(DATA_DIR / "benchmark_paper_moead.csv"),
        "out": str(MANUSCRIPT_DIR / "frameworks_perf_moead.tex"),
        "label": "tab:frameworks_perf_moead",
        "caption": "MOEA/D. Median runtime (seconds) by problem family across all frameworks",
    },
}


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Update frameworks_perf_*.tex variant tables from benchmark CSVs.")
    parser.add_argument(
        "--algo",
        action="append",
        choices=sorted(TABLE_SPECS.keys()),
        help="Algorithm table(s) to update. Can be passed multiple times. Default: all.",
    )
    return parser.parse_args()


def _get_family(problem_name: str) -> str:
    if problem_name.startswith("zdt"):
        return "ZDT"
    if problem_name.startswith("dtlz"):
        return "DTLZ"
    if problem_name.startswith("wfg"):
        return "WFG"
    return "Other"


def _sorted_frameworks(frameworks: list[str]) -> list[str]:
    order_map = {"VAMOS": 0, "pymoo": 1, "jMetalPy": 2, "DEAP": 3, "Platypus": 4}

    def sort_key(name: str) -> int:
        for k, v in order_map.items():
            if k.lower() == name.lower():
                return v
            if k in name:
                return v
        return 99

    return sorted(frameworks, key=sort_key)


def _make_table(family_df: pd.DataFrame, *, label: str, caption: str, generator: str) -> str:
    families = [col for col in ["ZDT", "DTLZ", "WFG"] if col in family_df.columns]
    caption = caption.strip()
    if caption.endswith("."):
        caption = caption[:-1]

    lines = [
        f"% Auto-generated by {generator}",
        "",
        r"\begin{table}[htbp]",
        r"\centering",
        rf"\caption{{{caption}}}",
        rf"\label{{{label}}}",
        r"\begin{tabular}{l|" + "r" * len(families) + "|r}",
        r"\toprule",
    ]

    header = " & ".join([f"\\textbf{{{f}}}" for f in families]) + " & \\textbf{Average}"
    lines.append(f"\\textbf{{Framework}} & {header} \\\\")
    lines.append(r"\midrule")

    for fw in _sorted_frameworks(family_df.index.tolist()):
        row = family_df.loc[fw]
        row_str = []
        for col in families + ["Average"]:
            val = float(row[col])
            col_min = float(family_df[col].min())
            if abs(val - col_min) < 1e-9:
                row_str.append(f"\\textbf{{{val:.2f}}}")
            else:
                row_str.append(f"{val:.2f}")
        lines.append(f"{fw} & {' & '.join(row_str)} \\\\")

    lines.extend([r"\bottomrule", r"\end{tabular}", r"\end{table}", ""])
    return "\n".join(lines)


def _load_family_table(csv_path: Path) -> pd.DataFrame:
    df = pd.read_csv(csv_path)
    if df.empty:
        raise SystemExit(f"No rows in CSV: {csv_path}")

    df["family"] = df["problem"].astype(str).apply(_get_family)

    family = df.groupby(["framework", "family"])["runtime_seconds"].median().unstack()

    # Keep only standard families; drop "Other" if present.
    family = family[[c for c in ["ZDT", "DTLZ", "WFG"] if c in family.columns]]

    # Average across available families.
    family["Average"] = family.mean(axis=1)

    # Paper tables show only the tuned VAMOS implementation (prefer numba, fallback to moocore/numpy).
    vamos_rep = None
    for candidate in ("VAMOS (numba)", "VAMOS (moocore)", "VAMOS (numpy)"):
        if candidate in family.index:
            vamos_rep = candidate
            break
    if vamos_rep is not None:
        family = family.rename(index={vamos_rep: "VAMOS"})

    # Drop other VAMOS variants.
    family = family.loc[~family.index.to_series().astype(str).str.contains(r"^VAMOS \(", regex=True)]

    return family


def main() -> None:
    args = _parse_args()

    try:
        generator = Path(__file__).resolve().relative_to(ROOT_DIR).as_posix()
    except Exception:
        generator = Path(__file__).name

    algos = args.algo or list(TABLE_SPECS.keys())
    for algo in algos:
        spec = TABLE_SPECS[algo]
        csv_path = Path(spec["csv"])
        out_path = Path(spec["out"])

        if not csv_path.is_file():
            raise SystemExit(f"Missing CSV: {csv_path}")
        if not out_path.parent.is_dir():
            raise SystemExit(f"Missing output dir: {out_path.parent}")

        family_df = _load_family_table(csv_path)
        latex = _make_table(
            family_df,
            label=spec["label"],
            caption=spec["caption"],
            generator=generator,
        )
        out_path.write_text(latex, encoding="utf-8")
        print(f"Updated: {out_path}")


if __name__ == "__main__":
    main()

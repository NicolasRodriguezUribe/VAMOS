"""Interactive wizard for scaffolding a custom VAMOS problem file.

Run via ``vamos create-problem`` or ``python -m vamos.experiment.cli.create_problem``.
"""

from __future__ import annotations

import argparse
import sys
from collections.abc import Sequence
from pathlib import Path

# ---------------------------------------------------------------------------
# Templates
# ---------------------------------------------------------------------------

_TEMPLATE_FUNCTIONAL = '''\
"""
Custom problem: {name}

Generated by: vamos create-problem
"""

from vamos import make_problem, optimize


def {func_name}(x):
    """Evaluate a single solution.

    Parameters
    ----------
    x : array of length {n_var}
        Decision variables ({bounds_desc}).

    Returns
    -------
    list of {n_obj} float
        Objective values (all minimized).
    """
    # TODO: Replace with your objective functions
{objectives_placeholder}
    return [{return_placeholder}]


# Create the problem -- VAMOS handles the rest
problem = make_problem(
    {func_name},
    n_var={n_var},
    n_obj={n_obj},
    bounds={bounds},
    encoding="real",
    name="{name}",
)

# Run optimization
if __name__ == "__main__":
    result = optimize(
        problem,
        algorithm="nsgaii",
        max_evaluations={budget},
        seed=42,
        verbose=True,
    )
    F = result.F
    print(f"\\nFound {{len(F)}} non-dominated solutions")
    for i in range({n_obj}):
        print(f"  f{{i}}: [{{F[:, i].min():.4f}}, {{F[:, i].max():.4f}}]")
'''

_TEMPLATE_CLASS = '''\
"""
Custom problem: {name}

Generated by: vamos create-problem

This template uses the class-based approach for full control.
For simpler problems, try: vamos create-problem --style functional
"""

from __future__ import annotations

import numpy as np
from vamos import optimize


class {class_name}:
    """{name} -- {n_obj}-objective optimization problem."""

    def __init__(self) -> None:
        self.n_var = {n_var}
        self.n_obj = {n_obj}
        self.xl = np.array({xl}, dtype=float)
        self.xu = np.array({xu}, dtype=float)
        self.encoding = "real"

    def evaluate(self, X: np.ndarray, out: dict[str, np.ndarray]) -> None:
        """Evaluate a batch of solutions.

        Parameters
        ----------
        X : ndarray of shape (N, {n_var})
            Batch of N solutions, each with {n_var} decision variables.
        out : dict
            Write objectives to out["F"] (shape N x {n_obj}).
        """
        # TODO: Replace with your objective functions (vectorized over N solutions)
{objectives_placeholder}

        result = {obj_stack}
        F = out.get("F")
        if F is not None and F.shape == result.shape:
            F[:] = result
        else:
            out["F"] = result


# Run optimization
if __name__ == "__main__":
    problem = {class_name}()
    result = optimize(
        problem,
        algorithm="nsgaii",
        max_evaluations={budget},
        seed=42,
        verbose=True,
    )
    F = result.F
    print(f"\\nFound {{len(F)}} non-dominated solutions")
    for i in range({n_obj}):
        print(f"  f{{i}}: [{{F[:, i].min():.4f}}, {{F[:, i].max():.4f}}]")
'''


# ---------------------------------------------------------------------------
# Interactive prompts
# ---------------------------------------------------------------------------


def _prompt_text(prompt: str, default: str) -> str:
    raw = input(f"  {prompt} [{default}]: ").strip()
    return raw or default


def _prompt_int(prompt: str, default: int, *, min_value: int = 1) -> int:
    while True:
        raw = _prompt_text(prompt, str(default)).strip()
        try:
            value = int(raw)
        except ValueError:
            print("  Please enter a whole number.")
            continue
        if value < min_value:
            print(f"  Please enter a value >= {min_value}.")
            continue
        return value


def _prompt_bounds(n_var: int) -> list[tuple[float, float]]:
    print(f"\n  Variable bounds (lower,upper for each of {n_var} variables):")
    use_same = _prompt_text(
        "Same bounds for all variables? (y/n)", "y"
    ).lower()
    if use_same in ("y", "yes"):
        lo = float(_prompt_text("  Lower bound for all variables", "0.0"))
        hi = float(_prompt_text("  Upper bound for all variables", "1.0"))
        return [(lo, hi)] * n_var

    bounds: list[tuple[float, float]] = []
    for i in range(n_var):
        while True:
            raw = _prompt_text(f"  x{i} bounds (lo,hi)", "0.0,1.0")
            parts = raw.split(",")
            if len(parts) != 2:
                print("  Enter two values separated by a comma, e.g. 0.0,1.0")
                continue
            try:
                lo_v, hi_v = float(parts[0].strip()), float(parts[1].strip())
            except ValueError:
                print("  Enter valid numbers, e.g. 0.0,1.0")
                continue
            if lo_v > hi_v:
                print(f"  Lower bound ({lo_v}) must be <= upper bound ({hi_v}).")
                continue
            bounds.append((lo_v, hi_v))
            break
    return bounds


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _to_identifier(name: str) -> str:
    """Convert ``'My Problem'`` to ``'my_problem'``."""
    ident = "".join(c if c.isalnum() else "_" for c in name.lower()).strip("_")
    # Collapse consecutive underscores
    while "__" in ident:
        ident = ident.replace("__", "_")
    return ident or "custom_problem"


def _to_class_name(name: str) -> str:
    """Convert ``'my problem'`` to ``'MyProblem'``."""
    parts = name.replace("_", " ").split()
    return "".join(word.capitalize() for word in parts if word) or "CustomProblem"


# ---------------------------------------------------------------------------
# Code generation
# ---------------------------------------------------------------------------


def _generate_functional(
    *,
    name: str,
    n_var: int,
    n_obj: int,
    bounds: list[tuple[float, float]],
    budget: int,
) -> str:
    func_name = _to_identifier(name)
    bounds_desc = ", ".join(
        f"x{i} in [{b[0]}, {b[1]}]" for i, b in enumerate(bounds)
    )

    obj_lines: list[str] = []
    return_parts: list[str] = []
    for i in range(n_obj):
        obj_lines.append(f"    f{i} = x[0]  # TODO: define objective {i}")
        return_parts.append(f"f{i}")

    return _TEMPLATE_FUNCTIONAL.format(
        name=name,
        func_name=func_name,
        n_var=n_var,
        n_obj=n_obj,
        bounds=bounds,
        bounds_desc=bounds_desc,
        objectives_placeholder="\n".join(obj_lines),
        return_placeholder=", ".join(return_parts),
        budget=budget,
    )


def _generate_class(
    *,
    name: str,
    n_var: int,
    n_obj: int,
    bounds: list[tuple[float, float]],
    budget: int,
) -> str:
    class_name = _to_class_name(name)
    xl = [b[0] for b in bounds]
    xu = [b[1] for b in bounds]

    obj_lines: list[str] = []
    for i in range(n_obj):
        obj_lines.append(
            f"        f{i} = X[:, 0]  # TODO: define objective {i}"
        )

    stack_parts = ", ".join(f"f{i}" for i in range(n_obj))
    obj_stack = f"np.column_stack([{stack_parts}])"

    return _TEMPLATE_CLASS.format(
        name=name,
        class_name=class_name,
        n_var=n_var,
        n_obj=n_obj,
        xl=xl,
        xu=xu,
        objectives_placeholder="\n".join(obj_lines),
        obj_stack=obj_stack,
        budget=budget,
    )


# ---------------------------------------------------------------------------
# CLI entry-point
# ---------------------------------------------------------------------------


def run_create_problem(argv: Sequence[str] | None = None) -> None:
    """Interactive wizard that scaffolds a custom VAMOS problem file."""
    parser = argparse.ArgumentParser(
        prog="vamos create-problem",
        description=(
            "Guided wizard to scaffold a custom optimization problem. "
            "Generates a ready-to-run Python file -- just fill in your objectives."
        ),
    )
    parser.add_argument("--name", help="Problem name (e.g. 'my_problem').")
    parser.add_argument("--n-var", type=int, help="Number of decision variables.")
    parser.add_argument("--n-obj", type=int, help="Number of objectives.")
    parser.add_argument("--output", "-o", help="Output file path.")
    parser.add_argument(
        "--style",
        choices=["functional", "class"],
        default=None,
        help=(
            "Template style: 'functional' (simple, uses make_problem) "
            "or 'class' (full control). Default: functional."
        ),
    )
    parser.add_argument(
        "--budget",
        type=int,
        default=None,
        help="Max evaluations for the generated run script.",
    )
    parser.add_argument(
        "--yes",
        action="store_true",
        help="Accept all defaults without prompting.",
    )
    args = parser.parse_args(argv)

    interactive = sys.stdin.isatty() and not args.yes

    print()
    print("  VAMOS Problem Creator")
    print("  " + "=" * 40)
    print("  Let's set up your custom optimization problem.\n")

    # ---- collect metadata ----
    if args.name:
        name = args.name
    elif interactive:
        name = _prompt_text("Problem name", "my_problem")
    else:
        name = "my_problem"

    if args.n_var is not None:
        n_var = args.n_var
    elif interactive:
        n_var = _prompt_int("How many decision variables?", 2)
    else:
        n_var = 2

    if args.n_obj is not None:
        n_obj = args.n_obj
    elif interactive:
        n_obj = _prompt_int("How many objectives to minimize?", 2)
    else:
        n_obj = 2

    if interactive:
        bounds = _prompt_bounds(n_var)
    else:
        bounds = [(0.0, 1.0)] * n_var

    if args.budget is not None:
        budget = args.budget
    elif interactive:
        budget = _prompt_int(
            "Evaluation budget (more = better results, slower)", 5000, min_value=100
        )
    else:
        budget = 5000

    if args.style:
        style = args.style
    elif interactive:
        style = _prompt_text(
            "Template style -- 'functional' (simpler) or 'class' (more control)",
            "functional",
        )
        if style not in ("functional", "class"):
            style = "functional"
    else:
        style = "functional"

    # ---- generate ----
    if style == "class":
        content = _generate_class(
            name=name, n_var=n_var, n_obj=n_obj, bounds=bounds, budget=budget
        )
    else:
        content = _generate_functional(
            name=name, n_var=n_var, n_obj=n_obj, bounds=bounds, budget=budget
        )

    # ---- write output ----
    if args.output:
        output_path = Path(args.output)
    else:
        filename = _to_identifier(name) + ".py"
        output_path = Path(filename)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content, encoding="utf-8")

    # ---- next steps ----
    print(f"\n  Created: {output_path.resolve()}")
    print()
    print("  Next steps:")
    print(
        f"    1. Open {output_path} and fill in your objective "
        "functions (look for TODO comments)"
    )
    print(f"    2. Run it:  python {output_path}")
    print(
        "    3. Tweak:   adjust bounds, budget, or algorithm as needed"
    )
    print()
    if style == "functional":
        print(
            "  Tip: Your function receives a single solution x "
            f"(array of length {n_var})."
        )
        print(
            f"       Return a list of {n_obj} values -- all are minimized."
        )
    else:
        print(
            f"  Tip: Your evaluate() receives X with shape (N, {n_var}) "
            "-- a batch of solutions."
        )
        print(
            f"       Write {n_obj} objectives per row to out['F']."
        )
    print()


__all__ = ["run_create_problem"]

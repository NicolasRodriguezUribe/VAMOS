Metadata-Version: 2.4
Name: vamos
Version: 0.1.0
Summary: Vectorized Architecture for Multiobjective Optimization Studies
Author-email: VAMOS Team <vamos@example.com>
Maintainer-email: VAMOS Maintainers <vamos-maintainers@example.com>
License: MIT
Project-URL: Homepage, https://github.com/yourusername/vamos
Project-URL: Documentation, https://vamos.readthedocs.io
Project-URL: Repository, https://github.com/yourusername/vamos
Project-URL: Changelog, https://github.com/yourusername/vamos/blob/main/CHANGELOG.md
Project-URL: Issues, https://github.com/yourusername/vamos/issues
Keywords: multiobjective optimization,evolutionary algorithms,NSGA-II,MOEA/D,SMS-EMOA,vectorized computation,numpy,numba
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: Operating System :: OS Independent
Classifier: Typing :: Typed
Requires-Python: >=3.11
Description-Content-Type: text/markdown
Requires-Dist: numpy>=2.0.0
Requires-Dist: numba>=0.62.1
Requires-Dist: moocore>=0.1.9
Requires-Dist: jmetalpy>=1.9.0
Requires-Dist: pymoo>=0.6.1.5
Provides-Extra: dev
Requires-Dist: pytest>=7.4.0; extra == "dev"

# VAMOS â€“ Vectorized Architecture for Multiobjective Optimization Studies

[![Python Version](https://img.shields.io/badge/python-3.11%2B-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

VAMOS is a lean research-oriented implementation of NSGA-II, MOEA/D, and SMS-EMOA tailored for experimentation with vectorized evolutionary kernels. The project focuses on keeping individuals in contiguous NumPy arrays (Structure-of-Arrays style) so that core operators can be swapped easily between backends such as pure NumPy, Numba-accelerated kernels, or the C-based [moocore](https://pypi.org/project/moocore/).

## Features

- ðŸš€ **Vectorized implementations** of popular multi-objective evolutionary algorithms
- âš¡ **Multiple backends** for performance optimization:
  - `numpy`: Pure Python/NumPy reference implementation
  - `numba`: JIT-compiled kernels for better CPU performance
  - `moocore`: C-based backend for maximum speed
  - `moocore_v2`: Enhanced C-based backend with additional optimizations
- ðŸ§ª **Tested** with comprehensive unit tests
- ðŸ“Š **Benchmarking** tools included
- ðŸ§© **Modular design** for easy extension

## Project Structure

```
.
â”œâ”€â”€ src/
â”‚   â””â”€â”€ vamos/                      # Main package
â”‚       â”œâ”€â”€ __init__.py            # Package metadata
â”‚       â”œâ”€â”€ main.py                # CLI entry point
â”‚       â”‚
â”‚       â”œâ”€â”€ algorithm/             # Algorithm implementations
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ config.py          # Configuration builders
â”‚       â”‚   â”œâ”€â”€ nsgaii.py          # NSGA-II implementation
â”‚       â”‚   â”œâ”€â”€ moead.py           # MOEA/D implementation
â”‚       â”‚   â”œâ”€â”€ smsemoa.py         # SMS-EMOA implementation
â”‚       â”‚   â”œâ”€â”€ weight_vectors.py  # Weight vector utilities
â”‚       â”‚   â””â”€â”€ hypervolume.py     # Hypervolume calculations
â”‚       â”‚
â”‚       â”œâ”€â”€ kernel/                # Computational backends
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ numpy_backend.py   # NumPy backend
â”‚       â”‚   â”œâ”€â”€ numba_backend.py   # Numba backend
â”‚       â”‚   â””â”€â”€ moocore_backend.py # moocore backends
â”‚       â”‚
â”‚       â””â”€â”€ problem/               # Test problems
â”‚           â”œâ”€â”€ __init__.py
â”‚           â”œâ”€â”€ zdt1.py            # ZDT1 problem
â”‚           â”œâ”€â”€ dtlz.py            # DTLZ problem suite
â”‚           â””â”€â”€ wfg.py             # WFG problem suite
â”‚
â”œâ”€â”€ tests/                         # Test suite
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ algorithm/                # Algorithm tests
â”‚   â”œâ”€â”€ kernel/                   # Backend tests
â”‚   â””â”€â”€ problem/                  # Problem tests
â”‚
â”œâ”€â”€ docs/                         # Documentation
â”‚   â””â”€â”€ CODING_GUIDELINES.md      # Development guidelines
â”‚
â”œâ”€â”€ results/                      # Output directory (created automatically)
â”œâ”€â”€ pyproject.toml                # Project configuration
â””â”€â”€ README.md                     # This file
```

## Installation

### Prerequisites

- Python 3.11 or higher
- pip (Python package manager)

### Using pip (recommended)

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/vamos.git
   cd vamos
   ```

2. Create and activate a virtual environment (recommended):
   ```bash
   # Linux/macOS
   python -m venv .venv
   source .venv/bin/activate
   
   # Windows
   python -m venv .venv
   .venv\Scripts\activate
   ```

3. Install the package in development mode with all optional dependencies:
   ```bash
   pip install -e ".[dev]"
   ```

### Development Setup

For development, install the pre-commit hooks to ensure code quality:

```bash
pre-commit install
```

## Usage

### Command Line Interface

The main entry point is the `vamos` command:

```bash
# Show help
vamos --help

# Run NSGA-II with default settings
vamos --algorithm nsgaii --engine numpy

# Run MOEA/D with Numba backend
vamos --algorithm moead --engine numba

# Run SMS-EMOA with moocore_v2 backend
vamos --algorithm smsemoa --engine moocore_v2
```

### Python API

```python
from vamos.algorithm import NSGAII, NSGAIIConfig
from vamos.problem.zdt1 import ZDT1Problem

# Create a problem instance
problem = ZDT1Problem(n_var=10)

# Configure the algorithm
config = NSGAIIConfig(
    pop_size=100,
    n_offspring=100,
    crossover=("sbx", {"eta": 20, "prob": 0.9}),
    mutation=("pm", {"eta": 20, "prob": 0.1}),
    selection=("tournament", {"pressure": 2})
)

# Create and run the algorithm
algorithm = NSGAII(config=config)
result = algorithm.run(problem, termination=("n_eval", 10000), seed=42)

# Access results
solutions = result["X"]
objectives = result["F"]
```

## Running VAMOS

Use the CLI in `main.py`. The most common options:

```powershell
# Run once with the default backend (numpy)
.\.venv\Scripts\python.exe main.py

# Choose a backend explicitly
.\.venv\Scripts\python.exe main.py --engine moocore_v2

# Switch algorithms (NSGA-II, MOEA/D, or SMS-EMOA)
.\.venv\Scripts\python.exe main.py --algorithm moead --engine numpy

# Run SMS-EMOA with the NumPy backend
.\.venv\Scripts\python.exe main.py --algorithm smsemoa --engine numpy

# Solve with every algorithm sequentially (per chosen backend/experiment)
.\.venv\Scripts\python.exe main.py --algorithm both

# Benchmark every backend sequentially
.\.venv\Scripts\python.exe main.py --experiment backends
```

Configuration parameters (population size, max evaluations, number of variables, etc.) are defined at the top of `main.py`. The configuration builders in `algorithm/config.py` (`NSGAIIConfig`, `MOEADConfig`, and `SMSEMOAConfig`) make it easy to experiment with different crossover/mutation settings, decomposition neighborhoods, or SMS-EMOA reference-point setups.

When running MOEA/D, decomposition weight vectors are loaded from `build/weights/*.csv`. If the requested file is missing, the CLI automatically generates a simplex-lattice design with enough vectors for the configured population size and writes it to disk for future runs.

SMS-EMOA relies on low-dimensional hypervolume contributions (up to three objectives) together with an adaptive reference point. Override the `.reference_point()` builder options if your objective scales require a custom reference vector.

## Output

Each run prints a detailed log:

- Problem metadata (decision variables, objectives, backend name)
- Performance metrics (total time, evaluations per second, final population size)
- Objective ranges and, for bi-objective problems, approximate front spread

Results are saved to `results/VAMOS_ZDT1/`:

- `FUN.csv`: final objective values for each solution
- `time.txt`: elapsed time in milliseconds

When running `--experiment backends` an additional table summarises time, evaluations/sec, and spread for each backend.

## Extending the Project

- **New problem definitions**: add a module under `problem/`, implement `evaluate`, and plug it into `main.py`.
- **Custom backends**: create a class with the same interface as `NumPyKernel` (methods for `nsga2_ranking`, `tournament_selection`, `sbx_crossover`, `polynomial_mutation`, `nsga2_survival`) and add a resolver branch in `_resolve_kernel`.
- **Alternative operators**: adjust `kernel/numpy_backend.py` or implement them in a dedicated backend â€“ the whole algorithm keeps individuals as NumPy arrays, so vectorized operations are straightforward.

## License

This project is distributed without an explicit license in the repository. Adapt or extend it according to your internal guidelines.

Happy optimizing with VAMOS!
